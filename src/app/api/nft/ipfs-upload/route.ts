// src/app/api/nft/ipfs-upload/route.ts
import { NextResponse } from 'next/server';
import { DB } from '@/lib/db';
import { kv } from '@vercel/kv';
import { uploadFileToPinata, uploadJsonToPinata, getPinataUrl } from '@/lib/pinata';

// Function to get next NFT number
async function getNextNftNumber(): Promise<number> {
  // Get current counter
  const currentCount = await kv.get('nft:counter') as number || 0;
  
  // Increase counter
  const nextCount = currentCount + 1;
  
  // Save new value
  await kv.set('nft:counter', nextCount);
  
  return nextCount;
}

export async function POST(request: Request) {
  try {
    const { wallet } = await request.json();
    
    if (!wallet) {
      return NextResponse.json({ error: 'Wallet address is required' }, { status: 400 });
    }
    
    // Get application
    const application = await DB.getApplicationByWallet(wallet);
    if (!application) {
      return NextResponse.json({ error: 'Application not found' }, { status: 404 });
    }
    
    // Check that application is in nft_approved status
    if (application.status !== 'nft_approved') {
      return NextResponse.json({ 
        error: `NFT not approved for minting, current status: ${application.status}` 
      }, { status: 400 });
    }
    
    // Check if already uploaded to IPFS
    const existingIpfs = await kv.hget(`application:${application.id}`, 'ipfsImage');
    if (existingIpfs) {
      const ipfsMetadata = await kv.hget(`application:${application.id}`, 'ipfsMetadata');
      const nftNumber = await kv.hget(`application:${application.id}`, 'nftNumber');
      
      return NextResponse.json({ 
        success: true, 
        message: 'Already uploaded to IPFS',
        ipfsImage: existingIpfs,
        ipfsMetadata,
        nftNumber,
        ipfsImageUrl: getPinataUrl(existingIpfs as string),
        ipfsMetadataUrl: ipfsMetadata ? getPinataUrl(ipfsMetadata as string) : null
      });
    }
    
    // Get image URL
    if (!application.imageUrl) {
      return NextResponse.json({ error: 'No image URL found for this application' }, { status: 400 });
    }
    
    // Load image by URL
    const imageResponse = await fetch(application.imageUrl);
    if (!imageResponse.ok) {
      return NextResponse.json({ 
        error: `Failed to fetch image from URL: ${imageResponse.statusText}` 
      }, { status: 500 });
    }
    
    // Get binary image data
    const imageBuffer = Buffer.from(await imageResponse.arrayBuffer());
    
    // Get metadata
    const metadataStr = await kv.hget(`application:${application.id}`, 'metadata');
    if (!metadataStr) {
      return NextResponse.json({ error: 'No metadata found for this application' }, { status: 400 });
    }
    
    // Parse metadata
    let metadata;
    try {
      metadata = typeof metadataStr === 'string' ? JSON.parse(metadataStr) : metadataStr;
    } catch (error) {
      return NextResponse.json({ 
        error: 'Failed to parse metadata JSON' 
      }, { status: 500 });
    }
    
    // Get next NFT number
    const nftNumber = await getNextNftNumber();
    
    // Upload image to IPFS
    const imageFileName = `dewild-${nftNumber}.png`;
    const imageDescription = `DeWild NFT #${nftNumber} by @${metadata.artist}`;
    
    console.log('Uploading image to IPFS...');
    const imageIpfsHash = await uploadFileToPinata(
      imageBuffer,
      imageFileName,
      { description: imageDescription }
    );
    console.log('Image uploaded to IPFS, hash:', imageIpfsHash);
    
    // Form NFT metadata in ERC721 format
    const nftMetadata = {
      name: `DeWild #${nftNumber}`,
      description: metadata.description || metadata.statement || `DeWild NFT generated by @${metadata.artist}`,
      image: `ipfs://${imageIpfsHash}`,
      external_url: `https://dewild.art/nft/${nftNumber}`,
      attributes: [
        {
          trait_type: "Animal",
          value: metadata.traits?.animal || "Unknown"
        },
        {
          trait_type: "Material",
          value: metadata.traits?.material || "Unknown"
        },
        {
          trait_type: "Material Color",
          value: metadata.traits?.material_color || "Unknown"
        },
        {
          trait_type: "Background",
          value: metadata.traits?.background || "Unknown"
        },
        {
          trait_type: "Pattern Color",
          value: metadata.traits?.pattern_color || "Unknown"
        },
        {
          trait_type: "Eyes Color",
          value: metadata.traits?.eyes_color || "Unknown"
        },
        {
          trait_type: "Artist",
          value: metadata.artist || "Unknown"
        },
        {
          trait_type: "Statement",
          value: metadata.statement || "None"
        }
      ]
    };
    
    // Upload metadata to IPFS
    console.log('Uploading metadata to IPFS...');
    const metadataFileName = `dewild-${nftNumber}.json`;
    const metadataIpfsHash = await uploadJsonToPinata(
      nftMetadata,
      metadataFileName
    );
    console.log('Metadata uploaded to IPFS, hash:', metadataIpfsHash);
    
    // Save IPFS hashes in KV storage for application
    await kv.hset(`application:${application.id}`, {
      ipfsImage: imageIpfsHash,
      ipfsMetadata: metadataIpfsHash,
      nftNumber: nftNumber,
      ipfsTimestamp: Date.now()
    });
    
    // Save token information for access via metadata API
    await kv.hset(`nft:${nftNumber}`, {
      ipfsImage: imageIpfsHash,
      ipfsMetadata: metadataIpfsHash,
      applicationId: application.id,
      wallet: wallet,
      artist: metadata.artist || "",
      statement: metadata.statement || "",
      animal: metadata.traits?.animal || "Unknown",
      material: metadata.traits?.material || "Unknown",
      material_color: metadata.traits?.material_color || "Unknown",
      background: metadata.traits?.background || "Unknown",
      pattern_color: metadata.traits?.pattern_color || "Unknown",
      eyes_color: metadata.traits?.eyes_color || "Unknown",
      timestamp: Date.now()
    });
    
    // Check if baseURI needs to be updated in contract (for first NFT)
    if (nftNumber === 1) {
      // Save information about first NFT for subsequent baseURI setting
      await kv.set('nft:firstMetadata', {
        nftNumber,
        ipfsHash: metadataIpfsHash,
        timestamp: Date.now()
      });
      
      console.log('First NFT uploaded to IPFS. You should update the baseURI in your contract.');
    }
    
    return NextResponse.json({ 
      success: true, 
      ipfsImage: imageIpfsHash,
      ipfsMetadata: metadataIpfsHash,
      nftNumber: nftNumber,
      ipfsImageUrl: getPinataUrl(imageIpfsHash),
      ipfsMetadataUrl: getPinataUrl(metadataIpfsHash),
      isFirstNft: nftNumber === 1
    });
    
  } catch (error: any) {
    console.error('Error uploading to IPFS:', error);
    return NextResponse.json(
      { error: 'Failed to upload to IPFS', details: error?.message },
      { status: 500 }
    );
  }
}